package em426.results;

import em426.api.*;
import em426.results.MetricSummary.*;
import javafx.beans.property.*;

import java.io.*;
import java.util.*;

/**
 * One metric is a dimension of performance (e.g. cost, utilization, satisfaction) 
 * for one object in a system model (for example a site, space, connection, person, population)
 * Note that the model object (if the site representation allows such abstraction) could be a set of objects.
 * 
 * A metric may have zero or more summary statistics (see MetricSummary)
 * A metric may have zero or one time series (see MetricTimeSeries)
 * 
 * A metric is defined then generated by an AnalysisEngine passing samples during simulation to this class 
 * (through an Analysis Result)
 * Multiple metrics make up an AnalysisResult.
 * @author Bryan R. Moser
 *
 */
public class Metric implements Iterable<MetricSummary>, Serializable{
	
	private static final long serialVersionUID = 1583304232116799628L;
	private static final int CompressVersion = 1;  // V1.0 2021-03-14

	SensorAPI modelObj;
	String	name;
	UUID 	objID;
	String	objName;
	Class<?>	objType;
	String	description;
	int		runsCount;
	
	private BooleanProperty timeSeries;
	
	private MetricTimeSeries series;
	private ArrayList<MetricSummary> summaries;
	
	//TODO add direction of utopia (increasing, decreasing, approaching)
	
	/**
	 * @param modelObj - the object (e.g. site, space, population, person) this metric is observing
	 * @param metricName - a name for this metric, typically the performance dimensions measured (e.g. cost, utilization)
	 * @param runsCount - the count of analysis runs from Monte Carlo or other iterative methods
	 */
	public Metric(SensorAPI modelObj, String metricName, int runsCount) {
		this.name = metricName;
		this.modelObj = modelObj;
		this.objName = modelObj.getName();
		this.objID=modelObj.getId();
		this.objType=modelObj.getType();
		this.runsCount = runsCount;
		
		timeSeries = new SimpleBooleanProperty(false);
		
		series = null;
		summaries = new ArrayList<MetricSummary>();
		
		// TODO elevate runsCount to SimResult
	}


	public int getRunsCount() {
		return runsCount;
	}

	public String getName() {
		if (name == null) return "";
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		if (description == null) return "";
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}


	public MetricTimeSeries getSeries() {
		return series;
	}
	
	public MetricSummary getSummary(int index) {
		return summaries.get(index);
	}
	
	public MetricSummary getSummary(SummaryType type_) {
		for (MetricSummary x: summaries) {
			if (x.getType() == type_) return x;
		}
		return null;
	}
	
	public SensorAPI getModelObject() {
		return this.modelObj;
	}
	
	public UUID getModelObjectID() {
		return this.objID;
	}
	
	public String getModelObjectName() {
		if (objName == null) return "";
		return this.objName;
	}
	
	public Class<?> getModelObjectType() {
		return this.objType;
	}
	
	public String getModelObjectTypeSimpleName() {
		return this.objType.getSimpleName();
	}

	public void addSummary(MetricSummary summary) {
		for (MetricSummary s: summaries)
			if (s.getType() == summary.getType())
				return; // don't add duplicate
		summaries.add(summary);
	}
	
	/**
	 * Creates and adds MetricSummary (ies) to this metric.
	 * It is possible to add more than one summary
	 * @param args the summary statistic to be collected for each run (e.g. min, max, average)
	 * 				  as defined in MetricSummary.SummaryType
	 */
	public void addSummary(SummaryType ... args ) {
		for (SummaryType t : args)
			addSummary(new MetricSummary(getModelObjectID(), getName(), t, runsCount));
	}

	/**
	 * A convenience method to add four summaries (SUM, MAX, MIN and AVG) and a time series of sample period
	 * @param period - the duration buckets for sampling
	 */
	public void addSummariesAndTimeSeries(long period){
		addSummary(SummaryType.SUM, SummaryType.MAX, SummaryType.MIN, SummaryType.AVG);
        setTimeSeries(period);
	}

	/**
	 * Sets the time series for this metric
	 * @param period -- the period duration for the bucketing of samples
	 */
	public void setTimeSeries(long period) {
		series = new MetricTimeSeries(name, modelObj, period, this.runsCount);
		timeSeries.set(true);
	}
	
	public void postProcess() {
		if (timeSeries.get())
			series.processFinalSample();
	}
	
/**
 * Adds a sample to any summary and timelines that have been added	
 * @param run - the number of the run, assumed to be contiguous and increasing
 * @param time - a time (in the analysis engine) for the sample
 * @param value - the value of the metric
 */
	public void addSample(int run, long time, double value) {
		
		for (MetricSummary x : summaries) {
			x.setValue(run, value);
		}
		
		if (series != null)
			series.addSample(run, time, value);
	}
	
	
	public boolean hasTimeSeries() {
		return timeSeries.get();
	}
	
	public BooleanProperty timeSeriesProperty() {
		return timeSeries;
	}
	
	public boolean hasSummaries() {
		return (summaries.size() > 0);
	}
	
	public int getSummariesCount() {
		return summaries.size();
	}

	public String toString() {
		return name;
	}

	/**
	 * Iterates of set of contained Metric Summaries
	 */
	public boolean hasNext() {
		return summaries.iterator().hasNext();
	}

	public MetricSummary next() {
		return summaries.iterator().next();
	}

	public Iterator<MetricSummary> iterator() {
		return summaries.iterator();
	}
	
	public boolean equals(Metric m) {
		if (m.objID == this.objID && m.name == this.name)
			return true;
		else
			return false;
	}
	

	
	// TODO covariance calculation for 2 metric summaries in this metric
}
