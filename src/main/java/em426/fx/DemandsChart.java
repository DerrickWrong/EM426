package em426.fx;

import em426.api.*;
import javafx.beans.binding.*;
import javafx.beans.property.*;
import javafx.beans.value.*;
import javafx.collections.*;
import javafx.fxml.*;
import javafx.scene.*;
import javafx.scene.chart.*;
import javafx.scene.chart.XYChart.*;
import javafx.scene.control.*;
import javafx.scene.layout.*;

import java.io.*;
import java.util.*;

public class DemandsChart extends BorderPane
{
    @FXML
    private ButtonBar topButtonBar;
	@FXML
	private StackedAreaChart<Integer, Number> demandSAChart;
    @FXML
    private NumberAxis xAxis;
	
	private ObjectProperty<DemandAPI> selectedDemand;
	private ListProperty<DemandAPI> demands;
	private ObjectProperty<ColorFactory> colors;

	ListChangeListener<DemandAPI> dListen;

	private static final int XAXIS_TICKUNIT = 24;


	/**
	 * A UI control that shows a graph based on a set of demands
	 * The control listens to the demands property for added, removed demands
	 * Each demand is listened for changes to demand attributes
	 * A colors map is generated and applied to each demand that is added.
	 * The series shown for each demand is selectable.
	 * @author Bryan R. Moser
	 * @since February 2022
	 */
	public DemandsChart() {
		// attach FXML to this control instance
		FXMLLoader loader = new FXMLLoader(getClass().getResource("DemandChart.fxml"));
		loader.setRoot(this);
		loader.setController(this);
		try {
			loader.load();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	    demands = new SimpleListProperty<DemandAPI>(FXCollections.observableArrayList());
		colors = new SimpleObjectProperty<ColorFactory>(new ColorFactory());
	    xAxis.setTickUnit(XAXIS_TICKUNIT);
	    
	    demandSAChart.setCreateSymbols(false);
	    
	    // trigger response if a demand is added or removed

	    ListChangeListener<DemandAPI> dListen= new ListChangeListener<DemandAPI>(){
    		@Override
    		public void onChanged(Change<? extends DemandAPI> c) {

    			while (c.next()) {
    				if (c.wasAdded()) {
    					List<? extends DemandAPI> addedSubList = c.getAddedSubList();
    					for (DemandAPI x : addedSubList) {
    						add(x);
    					}
    				}
    				if (c.wasRemoved()) {
    					List<? extends DemandAPI> removedList = c.getRemoved();
    					for (DemandAPI x : removedList) {
    						delete(x);
    					}
    				}
    			}
    		}
    		};
    		
    	    demands.addListener(dListen);
    	    
    	    selectedDemand = new SimpleObjectProperty<>();
    	    selectedDemand.addListener((obs, oldvalue, newvalue) -> {
    	    		setDemandHighlighted(oldvalue, false);
    	    		setDemandHighlighted(newvalue, true);
    			});
    	    
	}
	
	public ListProperty<DemandAPI> demandsProperty() {
		return demands;
	}
	/**
	 * @return A property holding a map of colors to specific demand unique IDs. 
	 * If the UUID exists in the color map, the charts shows the color for that element in the chart.
	 * Color are automatically generated by the chart as demands are added (according to internal color set)
	 */
	public ObjectProperty<ColorFactory> colorsProperty(){
		return colors;
	}
	
	
	public ObjectProperty<DemandAPI> selectedDemandProperty(){
		return selectedDemand;
	}

	// TODO tie to selectedDemand property
	private void setDemandHighlighted(DemandAPI d, boolean highlight) {
		// TODO iterate and change previous or all to less opaque fill
		for (Series<Integer, Number> x : demandSAChart.getData()) {
			Node xn = x.getNode();
			if (xn.getUserData().equals(d)) {
				Node fill = xn.lookup(".chart-series-area-fill");
				Node line = xn.lookup(".chart-series-area-line");
				
				String colTxt = colors.get().get(d.getId());
				String lineStyle = "-fx-stroke-width: "+ (highlight ? "5" : "1")
						+ "; -fx-stroke: " + (highlight ? colTxt+"ff" : colTxt+"99");
				fill.setStyle("-fx-fill: " + colTxt + (highlight ? "dd" : "99"));
				line.setStyle(lineStyle);
			}
		}
	}

	@FXML
	public void initialize()
	{        
	}
	
	private Series<Integer, Number> getSeriesForDemand(DemandAPI d) {
		for( Series x : demandSAChart.getData()) {
			if (x.getNode().getUserData().equals(d))
				return x;
		}
		return null;
	}

	
	private void createDemandChartSeries(DemandAPI d) {
		// Create a series for each demand

		var newSeries = new Series<Integer, Number>();
		newSeries.nameProperty().bind(d.nameProperty());
		
		addEffortPoints(newSeries, d);
		
		// Check for recurrence
		if (d.isRecur()) {
			addRecurPoints(newSeries, d);
		}

		// add listeners to underlying data model

		ChangeListener updateListener = (obs, oldval, newval) -> {
			newSeries.getData().clear();// TODO change just the difference
			addEffortPoints(newSeries, d);
			if (d.getRecur()) {
				removeRecurPoints(newSeries, d);	
				addRecurPoints(newSeries, d);
			}};
			
		d.startProperty().addListener(updateListener);
		d.stopProperty().addListener(updateListener);
		
		ChangeListener recurListener = (obs, oldval, newval) -> {
			if ((boolean) newval) 
				addRecurPoints(newSeries, d);
			else 
				removeRecurPoints(newSeries, d);	
		};
		
		d.recurProperty().addListener(recurListener);
		
		ChangeListener recurDetailsListener = (obs, oldval, newval) -> {
			if (d.getRecur()) {
				removeRecurPoints(newSeries, d);	
				addRecurPoints(newSeries, d);
			}};
		
		d.everyProperty().addListener(recurDetailsListener);
		d.untilProperty().addListener(recurDetailsListener);
		
		//TODO store listeners for removal
		
		newSeries.nameProperty().bind(d.nameProperty());

		colors.get().put(d.getId());

		demandSAChart.getData().add(newSeries);
		
		newSeries.getNode().setUserData(d); // store demand reference in node for lookup later
		
		Tooltip t = new Tooltip();
		t.textProperty().bind(d.nameProperty());
		Tooltip.install(newSeries.getNode(), t);
		
		Node fill = newSeries.getNode().lookup(".chart-series-area-fill");
		fill.setOnMouseClicked(event -> {
			selectedDemand.set(d);
		});

		setDemandHighlighted(d, false); // establishes the colors
	}
	
	private void addEffortPoints(Series<Integer, Number> series, DemandAPI d) {
		Data<Integer, Number> xy;
		double y = d.getEffortHrs(); // in hours
		for (int n = d.getStart(); n <= d.getStop(); n++) {
			xy = new Data<Integer, Number>(n, y);
			xy.YValueProperty().bind(Bindings.divide(d.effortProperty(), 3600.0));
			series.getData().add(xy);
		}
		sortdemandSAChart();
		if (d.getStop() > xAxis.getUpperBound()) 
			xAxis.setUpperBound(d.getStop()+XAXIS_TICKUNIT-d.getStop()%XAXIS_TICKUNIT);
	}
	
	private void removeEffortPoints(Series<Integer, Number> series, DemandAPI d) {
		//remove all point great than stop.
		series.getData().removeIf(item -> (item.getXValue() >= d.getStart() && item.getXValue() <= d.getStop()));
		sortdemandSAChart();
		xAxis.setUpperBound(getUpperBound());
	}
	
	private void addRecurPoints(Series<Integer, Number> series, DemandAPI d) {
			Data<Integer, Number> xy;
			int every = d.getEvery();
			for (int n = d.getStop()+1; n <= d.getUntil(); n++) { // add to the right in recurring pattern
				int x = n % every;
				
				xy = new Data<Integer, Number>(n, 0);
				if ((x >= d.getStart() && x <= d.getStop())) // if within range, bind to effort in hours
					xy.YValueProperty().bind(Bindings.divide(d.effortProperty(), 3600.0));

				series.getData().add(xy);
			}
			
			sortdemandSAChart();
			if (d.getUntil() > xAxis.getUpperBound()) 
				xAxis.setUpperBound(d.getUntil()+ XAXIS_TICKUNIT-d.getUntil()%XAXIS_TICKUNIT);
		}
	
	private void removeRecurPoints(Series<Integer, Number> series, DemandAPI d) {
		//remove all points greater than stop.
		int stop = d.getStop();
		series.getData().removeIf(item -> (item.getXValue() > stop));
		sortdemandSAChart();
		xAxis.setUpperBound(getUpperBound());
	}
	
	private double getUpperBound() {
		double max = 0;
		for (DemandAPI d : demands) {
			max = Math.max(max, (d.getRecur() ? d.getUntil() : d.getStop()));
		}
		return max+ XAXIS_TICKUNIT-max%XAXIS_TICKUNIT;
	}

	private void add(DemandAPI d) {
		// in case it has already been added, remove it first
		delete(d);
		
		// Create a new series for new demand
		createDemandChartSeries(d);
		sortdemandSAChart();
	}

	private void delete(DemandAPI d) {
		// Only a single demand needs to be updated
		for (Series<Integer, Number> x : demandSAChart.getData()) {
			if (x.getNode().getUserData().equals(d)) {	
				// we found the series corresponding to the demand already existing
				demandSAChart.getData().remove(x);
				colors.get().remove(d.getId());
				return;
			}
		}
		// TODO remove listeners from data model
	}

	private void sortdemandSAChart() {
		demandSAChart.getData().sort((o1,o2)->{
			ObservableList<Data<Integer, Number>> l1 = o1.getData();
			ObservableList<Data<Integer, Number>> l2 = o2.getData();
			if(l1.size() == 0 || l2.size() == 0)
				return 0;
			int start1 = l1.get(0).getXValue();
			int start2 = l2.get(0).getXValue();
			if(start1 > start2) 
				return 1; 
			if(start1 == start2) {
				int end1 = l1.get(l1.size()-1).getXValue();
				int end2 = l2.get(l2.size()-1).getXValue();	
				if (end1 < end2)
					return 1;
			}
			return 0;
		});
	}

	


}
